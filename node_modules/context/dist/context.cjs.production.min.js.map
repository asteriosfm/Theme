{"version":3,"file":"context.cjs.production.min.js","sources":["../src/index.ts"],"sourcesContent":["type TypeCTXRef = { [key: string]: any };\n\nexport interface ICTXFN {\n  (context: Context): any;\n}\ninterface Init {\n  (ctxRef?: TypeCTXRef, parentContext?: Context | void): TypeCTXRef | null;\n}\n\ntype ContextOptions = {\n  use: () => Context | void;\n  set: (value: any) => any;\n  addQueryableProperties: (ctxRef: TypeCTXRef) => TQueryableProperties;\n  init?: Init;\n};\n\ntype TQueryableProperties = { [key: string]: true };\n\nexport type TCTX = {\n  use: () => Context | void;\n  run: (ctxRef: TypeCTXRef, fn: ICTXFN) => any;\n  bind: (\n    ctxRef: TypeCTXRef,\n    fn: (...args: any[]) => any,\n    ...args: any[]\n  ) => (...runTimeArgs: any[]) => any;\n};\n\nconst getInnerName = (name: string): string => `__${name}`;\n\nclass Context {\n  private _parentContext: Context | null = null;\n  [key: string]: any;\n\n  static is(value: any): value is Context {\n    return value instanceof Context;\n  }\n\n  constructor(\n    { use, set, addQueryableProperties, init }: ContextOptions,\n    ctxRef: TypeCTXRef\n  ) {\n    const ctx = use();\n\n    const usedRef =\n      typeof init === 'function' ? init(ctxRef, ctx) ?? ctxRef : ctxRef;\n\n    const queryableProperties = addQueryableProperties(usedRef);\n\n    if (usedRef && typeof usedRef === 'object') {\n      for (const key in queryableProperties) {\n        if (Object.prototype.hasOwnProperty.call(usedRef, key)) {\n          this[getInnerName(key)] = usedRef[key];\n        }\n        this.addLookupProperty(key);\n      }\n    }\n\n    if (ctx) {\n      this.setParentContext(ctx);\n    }\n\n    set(this);\n  }\n\n  addLookupProperty(key: string) {\n    const innerName = getInnerName(key);\n\n    Object.defineProperty(this, key, {\n      get() {\n        return this.lookup(innerName);\n      },\n      set(value) {\n        throw new Error(\n          `Context: Unable to set \"${key}\" to \\`${JSON.stringify(\n            value\n          )}\\`. Context properties cannot be set directly. Use context.run() instead.`\n        );\n      },\n    });\n  }\n\n  // @ts-ignore - we actually do use lookup\n  private lookup(key: string) {\n    let ctx: Context = this;\n    do {\n      if (ctx.hasOwnProperty(key)) {\n        return ctx[key];\n      }\n      if (Context.is(ctx.parentContext)) {\n        ctx = ctx.parentContext;\n      } else {\n        return;\n      }\n    } while (ctx);\n  }\n\n  private setParentContext(parentContext: Context) {\n    if (Context.is(this)) {\n      this._parentContext = parentContext;\n    }\n  }\n\n  get parentContext(): Context | null {\n    return this._parentContext;\n  }\n}\n\nfunction createContext(init?: Init) {\n  const storage = {\n    ctx: undefined,\n  };\n\n  const queryableProperties: TQueryableProperties = {};\n\n  function addQueryableProperties(ctxRef: TypeCTXRef): TQueryableProperties {\n    if (!ctxRef || typeof ctxRef !== 'object') {\n      return {};\n    }\n\n    for (const key in ctxRef) {\n      if (Object.prototype.hasOwnProperty.call(ctxRef, key)) {\n        queryableProperties[key] = true;\n      }\n    }\n\n    return queryableProperties;\n  }\n\n  function use(): Context | void {\n    return storage.ctx;\n  }\n  function set(value: any) {\n    return (storage.ctx = value);\n  }\n  function clear() {\n    const ctx = use();\n\n    if (!Context.is(ctx)) {\n      return;\n    }\n\n    set(ctx.parentContext);\n  }\n  function run(ctxRef: TypeCTXRef, fn: ICTXFN) {\n    const ctx = new Context({ set, use, addQueryableProperties, init }, ctxRef);\n\n    const res = fn(ctx);\n\n    clear();\n    return res;\n  }\n\n  function bind(\n    ctxRef: TypeCTXRef,\n    fn: (...args: any[]) => any,\n    ...args: any[]\n  ) {\n    return function(...runTimeArgs: any[]) {\n      return run(ctxRef, function() {\n        return fn(...args, ...runTimeArgs);\n      });\n    };\n  }\n\n  return {\n    use,\n    run,\n    bind,\n  };\n}\n\nexport default createContext;\n"],"names":["getInnerName","name","Context","ctxRef","use","set","addQueryableProperties","init","ctx","usedRef","queryableProperties","key","Object","prototype","hasOwnProperty","call","addLookupProperty","setParentContext","this","is","value","innerName","defineProperty","get","lookup","Error","JSON","stringify","parentContext","_parentContext","storage","undefined","run","fn","res","bind","args","runTimeArgs"],"mappings":"oEA4BA,IAAMA,EAAe,SAACC,cAA8BA,GAE9CC,0BAUFC,SADEC,IAAAA,IAAKC,IAAAA,IAAKC,IAAAA,uBAAwBC,IAAAA,yBARG,SAWjCC,EAAMJ,IAENK,EACY,mBAATF,aAAsBA,EAAKJ,EAAQK,kBAAiBL,EAEvDO,EAAsBJ,EAAuBG,MAE/CA,GAA8B,iBAAZA,MACf,IAAME,KAAOD,EACZE,OAAOC,UAAUC,eAAeC,KAAKN,EAASE,UAC3CX,EAAaW,IAAQF,EAAQE,SAE/BK,kBAAkBL,GAIvBH,QACGS,iBAAiBT,GAGxBH,EAAIa,QA5BCC,GAAP,SAAUC,UACDA,aAAiBlB,gCA8B1Bc,kBAAA,SAAkBL,OACVU,EAAYrB,EAAaW,GAE/BC,OAAOU,eAAeJ,KAAMP,EAAK,CAC/BY,sBACSL,KAAKM,OAAOH,IAErBhB,aAAIe,SACI,IAAIK,iCACmBd,WAAae,KAAKC,UAC3CP,qFAQFI,OAAA,SAAOb,OACTH,EAAeU,OAChB,IACGV,EAAIM,eAAeH,UACdH,EAAIG,OAETT,EAAQiB,GAAGX,EAAIoB,sBACjBpB,EAAMA,EAAIoB,oBAILpB,MAGHS,iBAAA,SAAiBW,GACnB1B,EAAQiB,GAAGD,aACRW,eAAiBD,mDAKjBV,KAAKW,6NAIhB,SAAuBtB,OACfuB,EAAU,CACdtB,SAAKuB,GAGDrB,EAA4C,YAEzCJ,EAAuBH,OACzBA,GAA4B,iBAAXA,QACb,OAGJ,IAAMQ,KAAOR,EACZS,OAAOC,UAAUC,eAAeC,KAAKZ,EAAQQ,KAC/CD,EAAoBC,IAAO,UAIxBD,WAGAN,WACA0B,EAAQtB,aAERH,EAAIe,UACHU,EAAQtB,IAAMY,WAWfY,EAAI7B,EAAoB8B,OARzBzB,EAWA0B,EAAMD,EAFA,IAAI/B,EAAQ,CAAEG,IAAAA,EAAKD,IAAAA,EAAKE,uBAAAA,EAAwBC,KAAAA,GAAQJ,WAT9DK,EAAMJ,IAEPF,EAAQiB,GAAGX,IAIhBH,EAAIG,EAAIoB,eAQDM,QAeF,CACL9B,IAAAA,EACA4B,IAAAA,EACAG,cAdAhC,EACA8B,8BACGG,mCAAAA,2BAEI,sCAAYC,2BAAAA,yBACVL,EAAI7B,GAAQ,kBACV8B,eAAMG,SAASC"}